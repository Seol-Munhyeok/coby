# 채점 시스템 파일 설명

이 문서는 채점 시스템을 구성하는 각 파일의 역할과 상호작용을 설명합니다.

## 1. `Dockerfile`

### 역할
AWS Lambda에서 코드를 실행할 수 있는 환경을 정의하고 구성하는 파일입니다. Python, Java, C++ 코드를 컴파일하고 실행하는 데 필요한 모든 도구와 라이브러리를 포함하는 Docker 이미지를 생성합니다.

### 주요 구성 요소
- **`FROM public.ecr.aws/lambda/python:3.9`**: AWS Lambda의 공식 Python 3.9 런타임 이미지를 기반으로 합니다.
- **`RUN yum install ...`**: 채점에 필요한 패키지를 설치합니다.
  - `java-11-amazon-corretto-devel`: Java 컴파일러 (`javac`) 및 런타임 (`java`)
  - `gcc-c++`: C++ 컴파일러 (`g++`)
  - `dos2unix`: 텍스트 파일의 줄바꿈 형식을 통일하는 유틸리티
- **`RUN pip install ...`**: Python 라이브러리를 설치합니다.
  - `requests`: 백엔드 서버와 HTTP 통신을 하기 위해 사용됩니다.
  - `pymysql`: RDS 데이터베이스에 직접 연결하기 위해 사용됩니다.
- **`COPY app.py run.sh`**: Lambda 핸들러 코드(`app.py`)와 채점 스크립트(`run.sh`)를 이미지에 복사합니다.
- **`RUN chmod +x run.sh`**: `run.sh` 스크립트에 실행 권한을 부여합니다.
- **`CMD ["app.handler"]`**: Lambda가 실행될 때 `app.py` 파일의 `handler` 함수를 호출하도록 지정합니다.

---

## 2. `app.py` (Lambda 핸들러)

### 역할
채점 프로세스 전체를 총괄하는 메인 컨트롤러입니다. SQS로부터 채점 요청을 받아, 코드 다운로드, 테스트케이스 준비, 채점 스크립트 실행, 결과 전송까지의 모든 단계를 조율합니다.

### 실행 흐름
1.  **SQS 메시지 수신**: 채점할 코드의 정보(제출 ID, 문제 ID, 코드 S3 경로, 언어 등)가 담긴 SQS 메시지를 받아서 처리합니다.
2.  **임시 작업 공간 생성**: 각 채점 요청마다 `/tmp/{submission_id}` 라는 격리된 임시 디렉토리를 생성합니다.
3.  **소스 코드 다운로드**: SQS 메시지에 명시된 S3 경로에서 사용자 소스 코드를 임시 작업 공간으로 다운로드합니다.
4.  **테스트케이스 정보 조회**: **RDS 데이터베이스에 직접 연결**하여 `problems` 테이블에서 해당 문제의 테스트케이스(`testcase_s3_path`)와 정답 파일(`expected_result_s3_path`)의 S3 경로를 조회합니다.
5.  **테스트케이스/정답 파일 다운로드**: 조회한 S3 경로로부터 `testcase.txt`와 `result.txt` 파일을 임시 작업 공간으로 다운로드합니다.
6.  **`run.sh` 실행**: 준비된 환경에서 `run.sh` 스크립트를 `언어`와 `소스파일명`을 인자로 하여 실행합니다. Lambda의 남은 실행 시간을 고려하여 타임아웃을 설정합니다.
7.  **결과 파싱**: `run.sh`가 실행 후 생성한 `judge_result.json` 파일을 읽어 상세한 채점 결과(상태, 실행 시간, 메모리 사용량 등)를 파싱합니다.
8.  **백엔드 서버로 결과 전송**: 최종 채점 결과를 백엔드 API 서버로 HTTP POST 요청을 보내 업데이트합니다.

### 주요 환경 변수
- `RDS_HOST`, `RDS_USER`, `RDS_PASSWORD`, `RDS_DB_NAME`: RDS 데이터베이스 연결 정보
- `BACKEND_URL`: 채점 결과를 전송할 백엔드 API 서버의 URL

---

## 3. `run.sh` (채점 및 실행 스크립트)

### 역할
`app.py`의 지시를 받아 실제 코드의 컴파일, 실행, 채점을 담당하는 셸 스크립트입니다. 격리된 환경에서 사용자 코드를 실행하고, 결과를 측정하여 JSON 파일로 출력합니다.

### 실행 흐름
1.  **인자 수신**: `app.py`로부터 언어(`$1`)와 소스 파일명(`$2`)을 인자로 받습니다.
2.  **컴파일 (Java, C++)**:
    - Java의 경우 `javac`로 컴파일합니다.
    - C++의 경우 `g++`로 컴파일합니다.
    - 컴파일 실패 시 `Compile Error`로 처리하고 에러 메시지를 저장합니다.
3.  **코드 실행**:
    - `timeout 5s`: 사용자 코드의 실행 시간을 5초로 제한합니다. 시간 초과 시 `Time Limit Exceeded`로 처리합니다.
    - `/usr/bin/time -f "%e %M"`: 코드 실행 시간(초)과 최대 메모리 사용량(KB)을 측정합니다.
    - `< "$TESTCASE_FILE"`: `testcase.txt` 파일의 내용을 프로그램의 표준 입력으로 전달합니다.
    - `> "$OUTPUT_FILE"`: 프로그램의 표준 출력을 `user_output.txt` 파일에 저장합니다.
    - `2> "$ERROR_FILE"`: 런타임 에러(표준 에러)를 `runtime_error.txt` 파일에 저장합니다.
4.  **정답 비교**:
    - 실행이 성공적으로 끝나면, 사용자의 출력 파일(`user_output.txt`)과 정답 파일(`result.txt`)의 내용을 `diff` 명령어로 비교합니다.
    - 일치하면 `Accepted`, 불일치하면 `Wrong Answer`로 처리합니다.
5.  **결과 종합 및 JSON 출력**:
    - 위 모든 과정의 결과를 종합하여 채점 상태, 실행 시간, 메모리 사용량, 컴파일/런타임 에러 메시지, 사용자 출력 등을 포함하는 `judge_result.json` 파일을 생성합니다.
    - 이 파일은 `app.py`가 읽어서 최종 결과를 처리하는 데 사용됩니다.
